# Назначение компонентов в проекте

## Обзор архитектуры

Проект использует микросервисную архитектуру с несколькими инфраструктурными компонентами. Каждый компонент решает конкретную задачу.

---

## 1. PostgreSQL (База данных)

**Порт:** `5432`  
**Используется в:** `auth_service`, `order_service`, `payment_service`

### Зачем нужен

PostgreSQL — основная реляционная база данных для хранения:
- **Пользователей** (`auth_service`) — email, хеши паролей
- **Заказов** (`order_service`) — информация о заказах, статусы
- **Outbox сообщений** (`order_service`) — события для публикации в RabbitMQ
- **Платежей** (`payment_service`) — информация о платежах
- **Inbox сообщений** (`payment_service`) — для идемпотентной обработки

### Почему PostgreSQL

✅ **ACID-транзакции** — гарантируют консистентность данных  
✅ **Надежность** — проверенная временем БД  
✅ **Поддержка JSON** — удобно хранить payload событий  
✅ **Индексы** — быстрый поиск по email, order_id и т.д.

### Пример использования

```python
# order_service/app/db.py
# В одной транзакции:
async with session.begin():
    order = OrderORM(...)  # Сохраняем заказ
    outbox = OutboxMessageORM(...)  # Сохраняем событие
    # Оба сохраняются атомарно!
```

---

## 2. Redis (Кеш)

**Порт:** `6379`  
**Используется в:** `catalog_service`

### Зачем нужен

Redis используется для **кеширования** списка товаров в каталоге.

### Проблема без кеша

```python
# ❌ Без кеша: каждый запрос идет в БД
GET /products → SELECT * FROM products → 100ms
GET /products → SELECT * FROM products → 100ms  # Повторный запрос
GET /products → SELECT * FROM products → 100ms  # Еще раз
```

### Решение с Redis

```python
# ✅ С кешем: первый запрос в БД, остальные из кеша
GET /products → SELECT * FROM products → 100ms → Сохранить в Redis
GET /products → Redis.get() → 1ms  # В 100 раз быстрее!
GET /products → Redis.get() → 1ms
```

### Реализация в проекте

**Файл:** `services/catalog_service/app/main.py`

```python
@app.get("/products")
async def list_products():
    r = get_redis()
    
    # 1. Проверяем кеш
    data = r.get("catalog:products")
    if data:
        return json.loads(data)  # Возвращаем из кеша
    
    # 2. Если нет в кеше - загружаем из БД (или генерируем)
    products = [Product(...), ...]
    
    # 3. Сохраняем в кеш на 60 секунд
    r.set("catalog:products", json.dumps(products), ex=60)
    return products
```

### Преимущества

✅ **Скорость** — Redis работает в памяти, ответ за ~1ms  
✅ **Снижение нагрузки на БД** — меньше запросов к PostgreSQL  
✅ **Масштабируемость** — можно обслужить больше запросов  
✅ **TTL (Time To Live)** — кеш автоматически обновляется через 60 секунд

### Когда использовать Redis

- Часто запрашиваемые данные (каталог товаров)
- Данные, которые редко меняются
- Нужно снизить нагрузку на основную БД
- Требуется высокая скорость ответа

---

## 3. RabbitMQ (Очередь сообщений)

**Порты:** `5672` (AMQP), `15672` (Management UI)  
**Используется в:** `order_service`, `payment_service`, `notification_service`

### Зачем нужен

RabbitMQ — это **message broker** (брокер сообщений) для асинхронного взаимодействия между микросервисами.

### Проблема без очереди

```python
# ❌ Синхронные вызовы - все ждут друг друга
Order Service → Payment Service (HTTP) → ждем ответа
Order Service → Notification Service (HTTP) → ждем ответа
# Если Payment Service упал - весь процесс останавливается
```

### Решение с RabbitMQ

```python
# ✅ Асинхронная обработка через события
Order Service → публикует "order.created" → сразу отвечает клиенту
Payment Service → получает событие → обрабатывает в фоне
Notification Service → получает событие → отправляет уведомление
# Сервисы работают независимо!
```

### Реализация в проекте

#### 1. Order Service (издатель событий)

**Файл:** `services/order_service/app/outbox_publisher.py`

```python
# Публикует событие в RabbitMQ
await exchange.publish(
    aio_pika.Message(body=json.dumps(payload)),
    routing_key="order.created"
)
```

#### 2. Payment Service (подписчик)

**Файл:** `services/payment_service/app/main.py`

```python
# Подписывается на события
queue = await channel.declare_queue("payment_queue")
await queue.bind(exchange, routing_key="order.created")

# Получает и обрабатывает
async for message in queue.iterator():
    event = json.loads(message.body)
    await process_payment(event)
```

### Преимущества

✅ **Асинхронность** — сервисы не блокируют друг друга  
✅ **Отказоустойчивость** — если один сервис упал, другие продолжают работать  
✅ **Масштабируемость** — можно запустить несколько воркеров  
✅ **Гарантия доставки** — сообщения не теряются (persistent queues)

### Паттерны использования

1. **Event-Driven Architecture** — сервисы реагируют на события
2. **Transaction Outbox** — надежная публикация событий
3. **Transaction Inbox** — идемпотентная обработка событий
4. **Хореография** — каждый сервис независимо обрабатывает события

---

## 4. FastAPI (Веб-фреймворк)

**Используется во всех микросервисах**

### Зачем нужен

FastAPI — современный Python-фреймворк для создания REST API.

### Преимущества

✅ **Автоматическая документация** — Swagger UI на `/docs`  
✅ **Валидация данных** — через Pydantic  
✅ **Асинхронность** — поддержка async/await  
✅ **Типизация** — проверка типов на этапе разработки

### Пример

```python
@app.post("/orders", response_model=Order)
async def create_order(req: CreateOrderRequest):
    # FastAPI автоматически:
    # - Валидирует входные данные
    # - Генерирует документацию
    # - Проверяет типы
    return order
```

---

## 5. Docker & Docker Compose

### Зачем нужен

Docker позволяет:
- **Изолировать** каждый сервис в отдельном контейнере
- **Упростить развертывание** — один `docker compose up`
- **Гарантировать одинаковое окружение** — на любой машине работает одинаково
- **Управлять зависимостями** — сервисы поднимаются в правильном порядке

### Структура

```yaml
services:
  db:          # PostgreSQL
  redis:       # Кеш
  rabbitmq:    # Очередь
  auth_service:      # Микросервис
  catalog_service:   # Микросервис
  order_service:     # Микросервис
  # ...
```

---

## 6. JWT (JSON Web Tokens)

**Используется в:** `auth_service`

### Зачем нужен

JWT — стандарт для безопасной передачи информации между сервисами.

### Как работает

1. Пользователь логинится → `auth_service` выдает JWT токен
2. Клиент отправляет запросы с токеном: `Authorization: Bearer <token>`
3. Другие сервисы проверяют токен (можно валидировать через `auth_service`)

### Преимущества

✅ **Stateless** — не нужно хранить сессии на сервере  
✅ **Масштабируемость** — любой сервис может проверить токен  
✅ **Безопасность** — токен подписан секретным ключом

---

## 7. SQLAlchemy (ORM)

**Используется в:** `auth_service`, `order_service`, `payment_service`

### Зачем нужен

SQLAlchemy — ORM (Object-Relational Mapping) для работы с БД на Python.

### Преимущества

✅ **Абстракция** — не нужно писать SQL вручную  
✅ **Миграции** — Alembic для управления схемой БД  
✅ **Типобезопасность** — проверка типов на этапе разработки  
✅ **Асинхронность** — поддержка async/await

### Пример

```python
# Вместо SQL:
# SELECT * FROM orders WHERE id = 1

# Используем ORM:
order = await session.get(OrderORM, 1)
```

---

## Схема взаимодействия компонентов

```
┌─────────────────────────────────────────────────────────┐
│                    Клиент (Браузер/Telegram)              │
└─────────────────────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────┐
│              Web App / Telegram Bot                      │
│              (FastAPI, Jinja2, aiogram)                  │
└─────────────────────────────────────────────────────────┘
         │              │              │
         ▼              ▼              ▼
    ┌────────┐    ┌────────┐    ┌────────┐
    │ Auth   │    │Catalog │    │ Order  │
    │Service │    │Service │    │Service │
    └────────┘    └────────┘    └────────┘
         │              │              │
         │              │              │
    ┌────┴────┐    ┌────┴────┐    ┌────┴────┐
    │         │    │         │    │         │
    ▼         ▼    ▼         ▼    ▼         ▼
┌────────┐ ┌────┐ ┌────┐ ┌────┐ ┌────┐ ┌─────────┐
│Postgres│ │JWT │ │Redis│ │Redis│ │Postgres│ │RabbitMQ│
│  (БД)  │ │    │ │(Кеш)│ │(Кеш)│ │  (БД)  │ │(Очередь)│
└────────┘ └────┘ └────┘ └────┘ └────┘ └─────────┘
                                    │
                                    ▼
                            ┌──────────────┐
                            │ Payment      │
                            │ Service      │
                            │ (Inbox)      │
                            └──────────────┘
                                    │
                                    ▼
                            ┌──────────────┐
                            │ Notification │
                            │ Service      │
                            └──────────────┘
```

---

## Резюме: Зачем каждый компонент

| Компонент | Назначение | Зачем нужен |
|-----------|------------|-------------|
| **PostgreSQL** | Хранение данных | Надежное хранение пользователей, заказов, платежей |
| **Redis** | Кеширование | Ускорение ответов, снижение нагрузки на БД |
| **RabbitMQ** | Очередь сообщений | Асинхронное взаимодействие между сервисами |
| **FastAPI** | REST API | Создание эндпоинтов для микросервисов |
| **Docker** | Контейнеризация | Изоляция и упрощение развертывания |
| **JWT** | Аутентификация | Безопасная передача информации о пользователе |
| **SQLAlchemy** | ORM | Удобная работа с БД без SQL |

---

## Почему именно такая архитектура?

### Микросервисы
- Каждый сервис решает одну задачу
- Можно масштабировать независимо
- Легче тестировать и поддерживать

### Асинхронность (RabbitMQ)
- Сервисы не блокируют друг друга
- Высокая производительность
- Отказоустойчивость

### Кеширование (Redis)
- Быстрые ответы для частых запросов
- Меньше нагрузки на БД

### Транзакции (PostgreSQL)
- Гарантия консистентности данных
- ACID-свойства для критичных операций

Это стандартная архитектура для современных микросервисных систем!

